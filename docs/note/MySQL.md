## 1数据库隔离级别

数据库事务的隔离级别有 4 种，由低到高分别为：

READ-UNCOMMITTED (读未提交)未提交读(Read Uncommitted)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

READ-COMMITTED (读已提交)提交读(Read Committed)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

REPEATABLE-READ (可重复读) Repeated Read：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。（默认隔离级别）

SERIALIZABLE (可串行化)串行读(Serializable)：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

## 2Mysql有哪些引擎？区别

1.MyISAM：拥有较高的插入，查询速度，但不支持事务、不支持外键、只能表级锁定不支持行级锁定，性能比 InnoDB 高，非聚簇索引

2.InnoDB（默认引擎） ：5.5 版本后 Mysql 的默认数据库，事务型数据库的首选引擎，支持 ACID 事务，支持行级锁定，外键，主要关注事务，聚簇索引

3.BDB： 源自 Berkeley DB，事务型数据库的另一种选择，支持 COMMIT 和 ROLLBACK 等其他事务特性

4.Memory ：所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在 Mysql 重新启动时丢失

5.Merge ：将一定数量的MyISAM表联合而成一个整体，在超大规模数据存储时很有用

6.Archive ：非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive拥有高效的插入速度，但其对查询的支持相对较差

7.Federated： 将不同的Mysql服务器联合起来，逻辑上组成一个完整的数据库。非常适合分布式应用

8.Cluster/NDB ：高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用

9.CSV： 逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个.CSV文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV存储引擎不支持索引。

10.BlackHole ：黑洞引擎，写入的任何数据都会消失，一般用于记录binlog做复制的中继

## 3谈谈事务的4要素（ACID）

事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。

A (Atomicity) 原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样

C (Consistency) 一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏

I(Isolation)隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰

D (Durability) 持久性：在事务完成以后，该事务所对数据库所作的更改能持久的保存在数据库之中，并不会被回滚

## 4什么是乐观锁和悲观锁，INNODB 的行级锁有哪 2 种？

乐观锁是设定每次修改都不会冲突，只在提交的时候去检查

悲观锁设定每次修改都会冲突，持有排他锁（写锁）。 

行级锁分为共享锁和排他锁两种：

共享锁又称读锁，针对同一份数据，多个读操作可以同时进行，不会互相影响

排他锁又称写锁，当前写操作没有完成前，它会阻断其他写锁和读锁

##  5死锁

1、产生死锁的原因主要是：

（1）系统资源不足。（2） 进程运行推进的顺序不合适。（3）资源分配不当等。

如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。

2、产生死锁的四个必要条件：

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在未使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

3、解决死锁：重启数据库或者关闭死锁进程

## 6什么是主从复制

slave（从服务器） 会从 master （主服务器）读取 binlog 来进行数据同步

1、master 将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；

2、salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;

3、slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。

基本原则：每个 slave只有一个 master，每个 salve只能有一个唯一的服务器 ID，每个master可以有多个salve，1对多的关系

主从复制缺点：延时

## 7 说说数据库索引，优缺点

索引是什么？

官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前

面的目录，能加快数据库的查询速度

一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的

（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）

我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别

说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引

优势,1提高数据检索的效率，降低数据库的IO成本，2通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗，被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多

劣势：1索引会占据磁盘空间，2索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL 不仅要保存数据，还有保存或者更新对应的索引文件

按索引类型

普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。

唯一索引：于普通索引类似，区别是索引列中的值必须是唯一的，但是允许为空值。如果是组合索引，列值的组合必须唯一

主键索引：特殊的唯一索引，和唯一索引的区别是不允许有空值

全文索引：只能在文本类型 CHAR，VARCHAR，TEXT 类型字段上创建全文索引。主要用来查找文本中的关键字，而不是直接与索引中的值相比较，更像搜索引擎。字段长度比较大时，如果创建普通索引，在进行 like 模糊查询时效率比较低，这时可以创建全文索引。MyISAM 和 InnoDB 中都可以使用全文索引。

空间索引：MySQL 在5.7之后的版本支持了空间索引，而且支持 OpenGIS 几何数据模型。MySQL 在空间索引这方面遵循 OpenGIS 几何数据模型规则。

前缀索引：在文本类型如 CHAR，VARCHAR，TEXT 类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定

按索引列数量：

单列索引：在单个字段上创建的索引

组合索引：在多个字段上创建的索引，查询时使用了创建索引的第一个字段索引才会被引用。组合索引需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用

##  8为什么使用B+树？不使用B树

1、B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快

2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定

3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高

4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描

5、磁盘读写代价更低。树的非叶子结点里面没有数据，这样索引比较小，可以放在一个blcok（或者尽可能少的blcok）里面。避免了树形结构不断的向下查找，然后磁盘不停的寻道，读数据。这样的设计，可以降低io的次数

B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快

## 9Redo/Undo机制

Redo/Undo把所有对数据的更新都写到日志里。Redo log用来记录某数据库被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据；Undo lpg是用来记录数据更新前的值，保证数据更新失败可以回滚。假如数据库在执行的过程中，不小心崩了，可以通过该日志的方式，回滚之前已经执行成功的操作，实现事务的一致性。

场景举例：

假如某个时刻数据库崩溃，在崩溃之前有事务A和事务B在执行，事务A已经提交，而事务B还未提交。当数据库重启进行 crash-recovery 时，就会通过Redo log将已经提交事务的更改写到数据文件，而还没有提交的就通过Undo log进行roll back（回滚）。

## 10MySQL调优思路

1、sql语句优化

避免在索引列上使用计算

尽量避免全部查询，首先考虑在where和order by涉及的列上建索引

2、索引优化

3、表优化

首先表有主键，表有主键的话MySQL会创建聚簇索引，聚簇索引的好处是它的主键和数据行是在一行的，做explain查询语句的时候它的type是const，这是级别比较高的。

有主键时如果一条sql语句查询很慢，可以去看一下是否建立了相应的索引，建索引的话要尽量选择where条件后的、还有group by、join连接的字段作为你的索引列，这些索引也要排个序，要符合最左匹配原则。这种多列的索引列你要建立联合索引而不是单列索引，这是索引的选择。

另外写sql的时候不要将或者索引列放到一个表达式里，或者当你做一些反向判断比如notnull、不等于等这种关键词，可能会让索引失效。

如果数据查询非常频繁，可以考虑使用覆盖索引（一个索引包含所有需要查询的字段的值），覆盖索引可以直接在索引中里查到数据，减少回表次数，相对来说还是很快的。我们可以通过explain查看执行计划，如果你设置的索引没有生效的话，可能考虑一下是不是是不是走错索引。（innodb可能错，myisam是准确的）因为它的底层是随机采样，因为它不可能所有都标记上，所以它随机采样来计算你的索引基数是怎样的，如果它采样采错了，即使你的索引基数比较大，但是它认为你的索引选择性比较小，可能不走你的索引。可以通过强制加force index强制走索引，看行不行，不行的话就用analyze table刷新一下信息看有没有重新组队。关于调优的话就想到这些

## 11创建索引时如何选择索引（选择唯一索引？普通索引？）考察change buffer

普通索引：如果是写多读少的服务，假如它的唯一性要求不高，或者他的业务代码可以保证唯一性，我们可以考虑使用普通索引，普通索引可以使用到changebuffer，changebuffer可以把一些写操作缓存下来读的时候进行merge操作，可以提高写入速度和内存命中率，场景比如账单类日志类，写完后马上被访问的概率较小

唯一索引：如果业务要求字段唯一，但是业务代码不能保证唯一，使用唯一索引。为确保列的唯一，所以它要多一次判断的过程，但是这个判断开销很小。

change buffer使用条件：1、索引是辅助索引2、索引不唯一，原理：如果数据在内存中就直接更新，否则将更新操作缓存到change buffer，下次访问数据页的时候，再读入内存，执行记录的更新操作。作用：减少IO操作，提高效率

唯一索引为什么不能使用change buffer？唯一索引要先将数据页读入内存才能判断唯一性，如果已经读入内存了，那直接更新内存更快，没必要使用change buffer

区别：

1、普通索引可以有重复值，唯一索引不能

2、数据修改时，普通索引更快，因为普通索引可以使用change buffer

3、普通索引查到记录时，还要查到下一个不满足的记录才停止，唯一索引查到就返回了，但是性能差距不大

## 12MVCC和事务隔离级别的关系

一般的mvcc特点：

每行数据都存在一个版本，每次数据更新时都更新该版本

修改时Copy出当前版本随意修改，各事务之间无干扰

保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）

innodb实现方式：

事务以排他锁的形式修改原始数据

把修改前的数据存放于undo log，通过回滚指针与主数据关联

修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）

innodb引擎默认是Repeatable Read可重复读，但是数据库在这个级别下并不存在幻读，是因为mvcc多版本并发控制。MVCC生效的级别是可提交读和可重复读

它的实现依赖undo log与read view。undo log记录某行数据的多个版本，read  view用来判断当前版本数据的可见性

事务对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁，可重复读也消除了幻读

首先建立一个全局事务版本号，每次新来事务就+1并且作为新事务的版本号

插入原理：

数据版本号为当前事务版本号，删除版本号为null

删除原理：

将数据的删除版本号更新为当前事务版本号，相当于于不是实际删除，只是标记删除

查询原理：

1、查找数据版本号，小于或者等于当前版本的数据。保证读取的数据是本次事务开启前已有的或者本次事务修改的

2、查找删除版本号为null或者大于当前版本号的记录。保证读取的数据在当前事务之前没有被删除

修改原理：

1、将原记录的删除版本号修改为当前事务版本号

2、新插入一条记录，包含原记录数据以及本次修改的，数据版本号为当前事务版本号，删除版本号为null，不成功就回滚

优缺点：读取数据几乎不需要获得锁，查询时通过版本检查获得需要的数据版本，提高了并发度，MVCC在大部分情况下可以代替行级锁，降低了系统开销；为了实现多版本，innodb必须增加两个字段存储和维护版本信息，检索的时候要比较版本信息因此降低了查询效率，并且需要定期清理不需要的版本号，及时回收空间，也增加了开销

更多资料：[https://blog.csdn.net/Waves___/article/details/105295060#5%E3%80%81%E4%BE%8B%E5%AD%90%EF%BC%88%E5%B8%AE%E5%8A%A9%E7%90%86%E8%A7%A3%EF%BC%89](https://blog.csdn.net/Waves___/article/details/105295060#5、例子（帮助理解）)

## 13count(1)和count(\*)的区别

## 14数据库三大范式

1、第一范式：(确保每列保持原子性)

第一范式是最基本的范式。要求所有字段值都是不可分解的原子值，列不可再分，比如一个班级里把学号名字放一个字段就是非原子性的

第一范式的合理遵循需要根据系统的实际需求来定。比如需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储

2、第二范式：(确保表中的每列都和主键相关)，有主键，非主键都完全依赖主键，比如班级表里我们的学号、姓名、班级都依赖主键id

第二范式在第一范式的基础之上更进一层。一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中

3．第三范式：(确保每列都和主键列直接相关,而不是间接相关)，非主键直接依赖主键，非主键之间不能相互依赖。比如在班级表里再添加老师，那么多个学生又对应了多个老师，正确的做法是再建一个表不同班级对应不用老师，通过外键关联

## 15脏读、不可重复读、幻读

脏读：事务A更新了数据但是没有提交，事务B读取了更新未提交的数据，然后然后事务A回滚了，那么事务B读取的就是不正确的数据。就是读取到了其他事务想要修改但是没有修改成功的数据

不可重复读：同一个事务两次查询的数据不一致，可能是两次查询中有其他事务作了修改

幻读：一个事务两次查询的数据笔数不一致，比如事务A查询了数据，然后事务B在此时插入了几行数据，事务A再查询发现查到了先前没有的数据，就叫幻读。读取的数据条数变多了

不可重复读和幻读比较：不可重复读针对update或delete，后者针对的insert

## 16哪些情况下适合建索引？不适合？

适合：频繁使用where，与其他表有关联的字段（例如外键），排序字段可以建，分组字段可以建，因为分组的前提是排序，统计字段可以建

不适合：频繁更新的字段，where中用不到的字段，表数据很少，数据重复比较均匀的字段（唯一性很差，比如性别），参与列计算的字段

## 17最左匹配原则

含义：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配

最左匹配原则是针对联合索引的。索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树，从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用

假设一个（a，b）联合索引如下

![img](C:\Users\Mg\AppData\Local\YNote\data\qq8177A7236E9387E1EDFC4BE37074A1FE\1b0395f6e6de4e3e8977b1e9c37090d4\clipboard.png)

可以看到a值有序，b值无序，查询b=2就无法查询，因为b无序

在a值确定的时候，b有是有序的，所有a=1 and b=2 ，两个字段都可以使用索引

如果a>1 and b=1，就不走索引，因为a无序，碰到a>1就停止匹配

假设（a，b，c）联合索引

1、全值匹配查询

a=1  and b=2 and c=3，不影响查询结果，MySQL会自动优化查询顺序

2、匹配左边的列

a=1  and，a=1  and b=2，a=1  and b=2 and c=3，都从最左边开始匹配，用到了索引

b=2，c=3，b=1 and c=3，没从左边开始，没用索引，用的全表扫描

3、匹配列前缀

如果a是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描

a like 'As%'，前缀都是排好序的，走索引查询

a like '%As'，全表查询

a like '%As%'，全表查询

4、匹配范围值

a > 1 and a < 3，对最左边的列进行范围查询

a > 1 and a < 3 and b > 1，多个列同时进行范围查找时，只有对索引最左边的那个列进行范围查找才用到B+树索引，也就是只有a用到索引

5、精确匹配某一列并范围匹配另外一列

a = 1 and b > 3，a=1的情况下b是有序的，进行范围查找走的是联合索引

6、排序

order by a,b,c limit 10，因为b+树索引本身就是按照上述规则排序的，所以可以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了

order by b,c,a limit 10，颠倒顺序的没有用到索引，order by的子句后面的顺序也必须按照索引列的顺序给出

a =1 order by b,c limit 10，联合索引左边列为常量，后边的列排序可以用到索引

## 18explain执行计划重要字段

id：id代表执行select子句或操作表的顺序。

id相同，执行顺序由上往下

id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行

id相同和不同,同时存在,遵从优先级高的优先执行,优先级相同的按照由上至下的顺序执行

type：访问类型，查看SQL到底是以何种类型访问数据的，查询类型从最好到最差依次是:system>const>eq_ref>ref>range>index>All,一般情况下,得至少保证达到range级别,最好能达到ref

system:表只有一行记录,这是const类型的特例,平时不会出现

const:表示通过索引一次就找到了,const即常量,它用于比较primary key或unique索引,因为只匹配一行数据,所以效率很快,如将主键置于where条件中,mysql就能将该查询转换为一个常量

eq_ref:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配,常见于主键或唯一索引扫描

ref:非唯一性索引扫描,返回匹配某个单独值的行,它可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体

range:只检索给定范围的行,使用一个索引来选择行,如where语句中出现了between,<,>,in等查询,这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。

index:index类型只遍历索引树,这通常比All快,因为索引文件通常比数据文件小,index是从索引中读取,all从硬盘中读取

all:全表扫描,是最差的一种查询类型

key：实际使用的索引,如果key为null,则没有使用索引，有时候mysql可能用的索引不是最好的，可以使用force index

rows：根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数

Extra：重要的额外信息，特别注意损耗性能的两个情况，using filesort和using temporary

Using filesort:说明mysql会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取,mysql中无法利用索引完成的排序操作称为"文件排序"

Using temporary :使用了临时表保存中间结果,mysql在对查询结果排序时使用临时表,常见于order by和分组查询group by

Using index:表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。 其中的覆盖索引含义是所查询的列是和建立的索引字段和个数是一一对应的

Using where:表明使用了where过滤

Using join buffer:表明使用了连接缓存,如在查询的时候会有多次join,则可能会产生临时表

impossible where:表示where子句的值总是false,不能用来获取任何元祖

select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化

distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作，即一旦MySQL找到了与行相联合匹配的行，就不再搜索

## 19分库分表

垂直分库就是将一个表的列分开存储，将主码和常用字段放一个表，主码和不常用字段放一个表，表的行数是相同的。场景：某些字段经常使用某些很少使用。例如：按照业务垂直划分：可以按照业务分为资金、会员、订单三个数据库。优点：数据行变小，一个数据页能存储更多数据，查询时减少IO次数。缺点：需要管理冗余列，查询所有数据需要join操作

水平分库是将一个表的行分开存储。按照一定规则将记录分开存储，例如将id哈希，表的列数是相同的。场景：表的数据非常多，全放在一个表里数据查询变慢，例如比如每天处理的订单数量是海量的，可以按照一定的规则水平划分。或者数据本来就有各自的特点，例如是不同地区的数据。缺点：给应用增加复杂度，它通常在查询时需要多个表名，查询所有数据需要union操作。在许多数据库应用中，这种复杂性会超过它带来的优点，因为只要索引关键字不大，则在索引用于查询时，表中增加两到三倍数据量，查询时也就增加读一个索引层的磁盘次数。

单库单表

单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。

单库多表

随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。

可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。

多库多表

随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平区分。

分库分表规则

设计表的时候需要确定此表按照什么样的规则进行分库分表。例如，当有新用户时，程序得确定将此用户信息添加到哪个表中；同理，当登录的时候我们得通过用户的账号找到数据库中对应的记录，所有的这些都需要按照某一规则进行。

路由

通过分库分表规则查找到对应的表和库的过程。如分库分表的规则是user_id mod 4的方式，当用户新注册了一个账号，账号id的123,我们可以通过id mod 4的方式确定此账号应该保存到User_0003表中。当用户123登录的时候，我们通过123 mod 4后确定记录在User_0003中。

分库分表产生的问题，及注意事项

1.分库分表维度的问题

假如用户购买了商品,需要将交易记录保存取来，如果按照用户的纬度分表，则每个用户的交易记录都保存在同一表中，所以很快很方便的查找到某用户的 购买情况，但是某商品被购买的情况则很有可能分布在多张表中，查找起来比较麻烦。反之，按照商品维度分表，可以很方便的查找到此商品的购买情况，但要查找 到买人的交易记录比较麻烦。

所以常见的解决方式有：

通过扫表的方式解决，此方法基本不可能，效率太低了。

记录两份数据，一份按照用户纬度分表，一份按照商品维度分表。

通过搜索引擎解决，但如果实时性要求很高，又得关系到实时搜索。

2.联合查询的问题

联合查询基本不可能，因为关联的表有可能不在同一数据库中。

3.避免跨库事务

避免在一个事务中修改db0中的表的时候同时修改db1中的表，一个是操作起来更复杂，效率也会有一定影响。

4.尽量把同一组数据放到同一DB服务器上

例如将卖家a的商品和交易信息都放到db0中，当db1挂了的时候，卖家a相关的东西可以正常使用。也就是说避免数据库中的数据依赖另一数据库中的数据。

一主多备

在实际的应用中，绝大部分情况都是读远大于写。Mysql提供了读写分离的机制，所有的写操作都必须对应到Master，读操作可以在 Master和Slave机器上进行，Slave与Master的结构完全一样，一个Master可以有多个Slave,甚至Slave下还可以挂 Slave,通过此方式可以有效的提高DB集群的 QPS.

此外，可以看出Master是集群的瓶颈，当写操作过多，会严重影响到Master的稳定性，如果Master挂掉，整个集群都将不能正常工作。

所以

1. 当读压力很大的时候，可以考虑添加Slave机器的分式解决，但是当Slave机器达到一定的数量就得考虑分库了。

2. 当写压力很大的时候，就必须得进行分库操作。

MySQL使用为什么要分库分表

可以用说用到MySQL的地方,只要数据量一大, 马上就会遇到一个问题,要分库分表。

这里引用一个问题为什么要分库分表呢?MySQL处理不了大的表吗?

其实是可以处理的大表的。我所经历的项目中单表物理上文件大小在80G多,单表记录数在5亿以上，而且这个表 属于一个非常核用的表:朋友关系表。

但这种方式可以说不是一个最佳方式。因为面临文件系统如Ext3文件系统对大于大文件处理上也有许多问题。

这个层面可以用xfs文件系统进行替换。但MySQL单表太大后有一个问题是不好解决: 表结构调整相关的操作基本不在可能。所以大项在使用中都会面监着分库分表的应用。

从Innodb本身来讲数据文件的Btree上只有两个锁, 叶子节点锁和子节点锁,可以想而知道,当发生页拆分或是添加新叶时都会造成表里不能写入数据。

所以分库分表还就是一个比较好的选择了。

那么分库分表多少合适呢?

经测试在单表1000万条记录一下,写入读取性能是比较好的. 这样在留点buffer,那么单表全是数据字型的保持在800万条记录以下, 有字符型的单表保持在500万以下。

如果按 100库100表来规划,如用户业务:

500万*100*100 = 50000000万 = 5000亿记录。

心里有一个数了，按业务做规划还是比较容易的。

分库分表中间件：mycat、sharding